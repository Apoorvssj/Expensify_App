import { v4 as uuidv4 } from 'uuid';
import database from '../firebase/firebase';

//changed in v2 f15

//------see expenses-action-before-async.js in playground , to see before asynchronous action generator
//using startAddExpense as the function for async action(middle thunk needed,to dispatch functions)

//now in every other file where we dispatched addExpense, we will change that to startAddExpense , in AddExpensePage.js


// ADD_EXPENSE action generator, //will manipulate redux store
export const addExpense = (expense) => ({
    type: 'ADD_EXPENSE',
    expense
});

//alternate way of setting up defualt values,rather than in function argument as done in old file in playground

//async action, will write ro firebase ,and dispatch addExpense()
export const startAddExpense = (expenseData = {}) => {
    //retuning a function not object,
    //this function is internally called by redux with dispatch
    return (dispatch) => {
        //destructuring expenseData , to set defualts
        const {
            description = '',
            note = '',
            amount = 0,
            createdAt = 0
        } = expenseData;
        //es6 shortcut syntax to define properties in objects
        const expense = {description, note, amount, createdAt};
        //retuning for promise chaining in expense.test.js in actions
        return database.ref('expenses').push(expense).then((ref) => {
            //to change store
            dispatch(addExpense({
                id: ref.key, //now id is generated by firebase so need of uuid
                ...expense
            }));
        });
    };
};

//REMOVE_EXPENSE action generator,will manipluate store
//default value is not needed for id, id : id using shorthand,also destructuring,and setting up defult
export const removeExpense = ({id} = {}) => ({
    type: 'REMOVE_EXPENSE',
    id 
    
});

//async action function,will reemove data from database, and dispatch removeExpense()
export const startRemoveExpense = ({id} = {}) => {
    return (dispatch) => {
        //to promise chain in test cases 
        return database.ref(`expenses/${id}`).remove().then(() => {
            dispatch(removeExpense({id}));
        });
    };
};

//EDIT_EXPENSE action generator,will manipulate store
//no need to set defualts,becoz if dont have the id we wont be updating it in the first place
export const editExpense = (id, updates) => ({
    type: 'EDIT_EXPENSE',
    id,
    updates
});

//async action function,will update data to database, and dispatch editExpenses()
export const startEditExpense = (id, updates) => {
    return (dispatch) => {
        //retuning promise to allow us to do promise chaning and use then() in expenses.test.js
        //passing the updates object in update
        return database.ref(`expenses/${id}`).update(updates)
        .then(() => {
            dispatch(editExpense(id,updates));
        });
    };
};

//SET_EXPENSES , will manipulate store
//implicitly returning an object
export const setExpenses = (expenses) => ({
    type: 'SET_EXPENSES',
    expenses
});

//async action function,will fetch data from database, and dispatch setExpenses()
export const startSetExpenses = () => {
    return (dispatch) => {
        //retuning promise to allow us to do promise chaning and use then() in app.js for startSetExpenses and in expenses.test.js
       return database.ref('expenses')
       .once('value')
       .then((snapshot) => {
           //snapshot will be in object structure
           const expenses = []; 
           //array parsing, becoz we will recieve object from firebase,but we need array for redux store
           snapshot.forEach((childSnapshot) => {
               expenses.push({
                   id: childSnapshot.key,
                   ...childSnapshot.val()
               });
           });
           dispatch(setExpenses(expenses));
       });
    };
};



